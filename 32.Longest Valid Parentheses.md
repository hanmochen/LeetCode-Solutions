# 32. Longest Valid Parentheses



## Problem Description

Given a string containing just the characters `'('` and `')'`, find the length of the longest valid (well-formed) parentheses substring.

**Example 1:**

```
Input: "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()"
```

**Example 2:**

```
Input: ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()"
```



## Solution



Dynamic Programming

```python
#
# @lc app=leetcode id=32 lang=python3
#
# [32] Longest Valid Parentheses
#
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        s = s.lstrip(')').rstrip('(')
        if not s: return 0
        l = len(s)
        dp = l*[0]
        for index in range(1,l):
            if s[index]== ')':
                if(s[index-1] == '('):
                    dp[index]=2 if(index == 1) else dp[index-2]+2 
                else:
                    left = index-1-dp[index-1]
                    dp[index] = 0 if(left < 0 or s[left] == ')') else dp[left-1]+dp[index-1]+2
        return max(dp)
           
```



Using Stack



```python
#
# @lc app=leetcode id=32 lang=python3
#
# [32] Longest Valid Parentheses
#
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        indexStack = [-1]
        maxLen = 0
        for index,char in enumerate(s):
            if char == '(':
                indexStack.append(index)
            else:
                indexStack.pop()
                if indexStack:
                    lastIndex = indexStack[-1]
                    maxLen = max(maxLen,index-lastIndex)
                else:
                    indexStack.append(index)
            
        return maxLen
            
```







### Tips



动态规划：

- 用 `dp[i]` 记录以 `s[i]` 结尾的最长匹配长度，如果无法匹配为 `0`
- 初始化为 `-1`, 只需更新 `）`的  `dp` 值 `s[i]=')'` 时 
- `s[i-1]=='('`
  - 